 (Жизненный цикл процесса)
 
 Появление процесса в системе 
 1) Int - 1й процесс в системе
 2) функ.fork() - порождет новый процесс со всеми его атрибутами и ресурсами(сист.вызова clone())
 3) После вызова fork() и дочерний и родительский процессы продолжают работу с точки вызова fork()
 4) Дочернему процессу Fork() возвращает 0, родительскому - PID порожденного процесса.
 5) Дочерний процесс - полная копия родительского, за исключением PID. 
 6) Первым управление получает child
 7) Процесс и поток для ядра linux - одинаковые сущности. 
 8) Поток отличается только наличием разделяемых ресурсов. 
 
 (Copy-on-write)
 Адресное пространство родителя и порожденного процесса совместное
 Дубликат ресурсов создается только при попытке изменить данные
 Для создания потока используется тот же системный вызов clone()
 
 (Новый процесс: exec
 exec загружает бинарный файл в адресное пространство процесса 
 выполнение начинается с точки входа в программу 
 при выполнении сразу после fork() копирования страниц памяти и происходит
 
 (Смерть процесса )
 1) Процесс заканчивается системным вызовом exit() либо сигналом завершения
 2) Сигнал процессу можно отправить командой kill 
 3) После завершения дочерний процесс находитс в состоянии зомби
 4) Если род.процесс завершился раньше дочернего родительским становится либо другой потом
 
 (Состояния процесса: Ready) 
 1) (R) процесс готов к выполнению 
 2) Ждет выделения процессорного времени планировщиком в очереди 
 3) Среднюю очередь ожидающих процессор процессов показывает Load average
 
 (Состояние процесса: Остановлен )
 1) Остановлен - процесс прекращает работу до получение сигнала SIGCONT
 2) Используют транссировщики 
 3) Сочетание клавишь CTRL+Z или сигнал SIGSTOP отправляет процесс в это состояние 
 
 (Состояние процесса: Sleeping) 
 1) Sleeping - процесс ожидании
 2) Вызов функции sleep() отправляет процесс в состоянии S 
 3) Как только ресурс доступен - процесс переходит в состояние READY или Running 
